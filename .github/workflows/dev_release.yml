---
name: Dev Release
run-name: dev-release

on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false # Don't cancel - could interrupt publishing and leave partial releases

permissions:
  contents: write
  pull-requests: read

jobs:
  dev-release:
    name: Dev Release
    runs-on: ubuntu-latest
    container:
      image: arthurdw/rust-ci:latest

    # Skip if this is a version bump commit (from weekly release)
    if: "!contains(github.event.head_commit.message, 'chore(release):')"

    steps:
      - name: Get token
        id: get_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.RONKY_CD_APP_ID }}
          private-key: ${{ secrets.RONKY_CD_TOKEN }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Check out repository
        uses: actions/checkout@v6
        with:
          token: ${{ steps.get_token.outputs.token }}
          fetch-depth: 0

      - uses: Swatinem/rust-cache@v2

      - name: Fix repository permissions
        run: |
          chown -R $(id -u):$(id -g) .

      - name: Install GitHub CLI
        run: |
          (type -p wget >/dev/null || (apt update && apt-get install wget -y)) \
            && mkdir -p -m 755 /etc/apt/keyrings \
            && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \
            && cat $out | tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
            && chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
            && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
            && apt update \
            && apt install gh -y

      - name: Get last stable release
        id: last_stable
        run: |
          # Get the last STABLE release (exclude -dev pre-releases)
          # This ensures dev releases accumulate labels correctly between stable releases
          LAST_STABLE_TAG=$(gh api repos/${{ github.repository }}/releases \
            --jq '[.[] | select(.prerelease == false) | .tag_name][0]' \
            2>/dev/null || echo "")

          if [ -z "$LAST_STABLE_TAG" ] || [ "$LAST_STABLE_TAG" = "null" ]; then
            echo "No previous stable release found"
            LAST_STABLE_DATE=$(date -d "30 days ago" -Iseconds)
            echo "last_stable_tag=" >> $GITHUB_OUTPUT
          else
            echo "Last stable release: $LAST_STABLE_TAG"
            LAST_STABLE_DATE=$(gh api repos/${{ github.repository }}/releases/tags/$LAST_STABLE_TAG --jq .published_at)
            echo "last_stable_tag=$LAST_STABLE_TAG" >> $GITHUB_OUTPUT
          fi

          echo "last_stable_date=$LAST_STABLE_DATE" >> $GITHUB_OUTPUT
          echo "Last stable release date: $LAST_STABLE_DATE"
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}

      - name: Check for code changes
        id: check_changes
        run: |
          LAST_TAG="${{ steps.last_stable.outputs.last_stable_tag }}"

          if [ -z "$LAST_TAG" ]; then
            echo "No previous stable release found, proceeding with dev release"
            echo "has_code_changes=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Checking changes since: $LAST_TAG"

          # Check if there are code changes (excluding docs, CI, etc.)
          CODE_CHANGES=$(git diff --name-only ${LAST_TAG}..HEAD -- . \
            ':!.github' \
            ':!*.md' \
            ':!.gitignore' \
            ':!.pre-commit-config.yaml' \
            ':!docs/' \
            ':!.readme/' \
            2>/dev/null | wc -l || echo "0")

          echo "Code changes since $LAST_TAG: $CODE_CHANGES files"

          if [ "$CODE_CHANGES" -gt 0 ]; then
            echo "has_code_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_code_changes=false" >> $GITHUB_OUTPUT
            echo "No code changes detected, skipping dev release"
          fi
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}

      - name: Get all PR labels since last stable release
        id: pr_labels
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          LAST_STABLE_DATE="${{ steps.last_stable.outputs.last_stable_date }}"
          echo "Collecting PR labels since: $LAST_STABLE_DATE"

          # Get ALL merged PRs since the last STABLE release with pagination
          # This ensures we find the highest bump type across all PRs, not just the current one
          MERGED_PRS=$(gh api graphql --paginate -f query='
            query($owner: String!, $repo: String!, $cursor: String) {
              repository(owner: $owner, name: $repo) {
                pullRequests(states: MERGED, first: 100, after: $cursor, orderBy: {field: MERGED_AT, direction: DESC}) {
                  nodes {
                    number
                    mergedAt
                    labels(first: 10) {
                      nodes {
                        name
                      }
                    }
                  }
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                }
              }
            }
          ' -f owner='${{ github.repository_owner }}' -f repo='${{ github.event.repository.name }}' \
            --jq --arg since "$LAST_STABLE_DATE" '
              .data.repository.pullRequests.nodes[]
              | select((.mergedAt | fromdateiso8601) > ($since | fromdateiso8601))
              | .labels.nodes[].name
            ' | grep "^release:" | sort | uniq || echo "")

          echo "All release labels since last stable release:"
          echo "$MERGED_PRS"

          # Determine bump type based on HIGHEST priority label across ALL PRs
          if echo "$MERGED_PRS" | grep -q "release:major"; then
            BUMP_TYPE="major"
          elif echo "$MERGED_PRS" | grep -q "release:minor"; then
            BUMP_TYPE="minor"
          elif echo "$MERGED_PRS" | grep -q "release:patch"; then
            BUMP_TYPE="patch"
          else
            BUMP_TYPE="patch"
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Determined bump type (highest across all PRs): $BUMP_TYPE"
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}

      - name: Calculate dev version
        id: version
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          # Get the BASE version from the last stable release tag (not from Cargo.toml)
          # This ensures consistent version calculation regardless of any -dev versions in the repo
          LAST_STABLE_TAG="${{ steps.last_stable.outputs.last_stable_tag }}"

          if [ -z "$LAST_STABLE_TAG" ]; then
            # Fallback to Cargo.toml if no stable release exists
            BASE_VERSION=$(grep -m 1 '^version = ' Cargo.toml | cut -d '"' -f 2 | cut -d- -f1)
          else
            # Extract version from tag (remove 'v' prefix)
            BASE_VERSION=$(echo "$LAST_STABLE_TAG" | sed 's/^v//')
          fi

          echo "Base version (from last stable release): $BASE_VERSION"

          # Also get current Cargo.toml version for updating later
          CURRENT_VERSION=$(grep -m 1 '^version = ' Cargo.toml | cut -d '"' -f 2)
          echo "Current Cargo.toml version: $CURRENT_VERSION"

          # Parse version components from the BASE version
          MAJOR=$(echo $BASE_VERSION | cut -d. -f1)
          MINOR=$(echo $BASE_VERSION | cut -d. -f2)
          PATCH=$(echo $BASE_VERSION | cut -d. -f3 | cut -d- -f1)  # Remove any pre-release suffix

          # Calculate next version based on bump type
          BUMP_TYPE="${{ steps.pr_labels.outputs.bump_type }}"
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "Next version (based on $BUMP_TYPE bump): $NEXT_VERSION"

          # Create dev version with short commit hash
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          DEV_VERSION="${NEXT_VERSION}-dev.${SHORT_SHA}"
          echo "Dev version: $DEV_VERSION"

          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "dev_version=$DEV_VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Update version for dev release
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          DEV_VERSION="${{ steps.version.outputs.dev_version }}"
          CURRENT_VERSION="${{ steps.version.outputs.current_version }}"
          echo "Setting version to: $DEV_VERSION (from $CURRENT_VERSION)"

          # Update workspace version in root Cargo.toml (matches any version string)
          sed -i "s/^version = \".*\"/version = \"$DEV_VERSION\"/" Cargo.toml

          # Update workspace dependency versions (escape any special characters in current version)
          ESCAPED_CURRENT=$(echo "$CURRENT_VERSION" | sed 's/[.[\*^$()+?{|]/\\&/g')
          sed -i "s/version = \"$ESCAPED_CURRENT\"/version = \"$DEV_VERSION\"/g" Cargo.toml

          # Verify the change
          echo "Updated Cargo.toml:"
          grep -E "^version = |version = \"$DEV_VERSION\"" Cargo.toml | head -5

      - name: Update Cargo.lock
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          cargo update --workspace

      - name: Build and test
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          cargo build --release --all-features
          cargo test --all --release

      - name: Commit version changes and create tag
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          DEV_VERSION="${{ steps.version.outputs.dev_version }}"
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Commit version changes so the tag points to the exact sources used for the release
          # This commit won't be pushed to main - only the tag will be pushed
          git add Cargo.toml Cargo.lock
          git commit -m "chore(dev-release): v${DEV_VERSION}"

          # Create tag pointing to the commit with version changes
          git tag "v${DEV_VERSION}" -m "Dev release v${DEV_VERSION}"

      - name: Push tag
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          # Only push the tag, not the commit - keeps main clean while ensuring
          # the tag points to a commit with the correct version in Cargo.toml
          git push origin "v${{ steps.version.outputs.dev_version }}"
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}

      - name: Create GitHub pre-release
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          DEV_VERSION="${{ steps.version.outputs.dev_version }}"
          gh release create "v${DEV_VERSION}" \
            --title "v${DEV_VERSION}" \
            --notes "Development release based on commit ${{ github.sha }}.

          This is a pre-release version for testing purposes.
          For stable releases, please use the latest non-dev version.

          **Changes in this release:**
          - Based on stable release: v${{ steps.version.outputs.base_version }}
          - Next stable version will be: v${{ steps.version.outputs.next_version }}
          - Bump type: ${{ steps.pr_labels.outputs.bump_type }}
          - Commit: ${{ github.sha }}" \
            --prerelease
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}

      - name: Publish to crates.io
        if: steps.check_changes.outputs.has_code_changes == 'true'
        run: |
          # Publish crates in dependency order
          for crate in arri_common ronky_derive arri_repr ronky; do
            echo "Publishing $crate..."
            cd $crate
            cargo publish --allow-dirty || echo "Warning: $crate publish failed (may already exist)"
            cd ..
            # Wait a bit for crates.io to index
            sleep 30
          done
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: No dev release needed
        if: steps.check_changes.outputs.has_code_changes == 'false'
        run: echo "No code changes detected since last release. Skipping dev release."
